// OpenGLApplication.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include "glut.h"
#include <gl/gl.h>
#include "PerlinNoise.h"
#include <string>
#include <iomanip>
#include <vector>
#include "Color.h"





int screen_width=1280;
int screen_height=720;
float camdepth=21;
float camx = -25.8, camy = 13.6;
float scrollSpeed = 1;
unsigned int seed= 325;
size_t dimPlanx, dimPlanz;
int keyState = 0;
std::string stateName[] = { "Seed", "Amplitudine", "Frecventa", "AplicareZ", "Persistenta"};

PerlinNoise pn;

float frequency = 1.0f, amplitude = 15.0f, waterHeight = 20.0f, persistenta = 10.0f;





GLfloat light_position[] = { 40., 10.0, 40.0, 0.0 };
Color currentTopColor, currentSideColor;

float cube[450][450];


float perlinZ=0.1;

struct point{

	float x, y, z;

}  camTarget;



void printData()
{
	std::cout << stateName[0] << ": " << seed << " " << stateName[1] << ": " << amplitude << " " << stateName[2] << ": " << frequency << " " << stateName[3] << ": " << perlinZ << " " << stateName[4] << ": " << persistenta << '\n';
	std::cout << "Optiune curenta: " << stateName[keyState] << '\n';
	std::cout << "\n";
}


void initOpenGL()
{
	Color sky = Color::Sky();
	
	glClearColor(sky.r(), sky.g(), sky.b(), 0.0f);
	glShadeModel(GL_SMOOTH);
	glViewport(0, 0, screen_width, screen_height);
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	gluPerspective(45.0f, (GLfloat)screen_width/(GLfloat)screen_height, 1.0f, 1000.0f);
	glEnable(GL_DEPTH_TEST);
	glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
	glMatrixMode(GL_MODELVIEW);
	glEnable(GL_LIGHTING);
	glEnable(GL_LIGHT0);
	glEnable(GL_COLOR_MATERIAL);
	glLightfv(GL_LIGHT0, GL_POSITION, light_position);






	camTarget.x = 150;
	camTarget.y = 0;
	camTarget.z = 150;

	

	camTarget.x = dimPlanx /2;
	camTarget.y = 0;
	camTarget.z = dimPlanz / 2;


}






void renderScene(void)
{
	
	
	

	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\

		glLoadIdentity();
	gluLookAt(camx, camy, camdepth,
		camTarget.x, camTarget.y, camTarget.z,
		0.0, 1.0, 0.0);


	


	



	

	currentTopColor = Color::Water();


	glColor3f(currentTopColor.r(), currentTopColor.g(), currentTopColor.b());

	glBegin(GL_QUADS);


	glVertex3f(0.0f, waterHeight, 0.0f);
	glVertex3f(dimPlanx, waterHeight, 0.0f);
	glVertex3f(dimPlanx, waterHeight, dimPlanz);
	glVertex3f(0.0f, waterHeight, dimPlanz);
	glEnd();

	
	for (float i = 0.5f; i < dimPlanx; i += 1)
	{
		for (float j = 0.5f; j < dimPlanz; j += 1)
		{
			size_t newi = i - 0.5, newj = j - 0.5;
			currentTopColor = Color::Grass();
			currentSideColor = Color::Dirt();
			if (cube[newi][newj] < waterHeight + 2)
			{
				currentTopColor = Color::Sand();
				currentSideColor = Color::DarkSand();
			}
			else 
				if (cube[newi][newj] > 100)
				{
					currentTopColor = Color::Snow();
					currentSideColor = Color::DarkSnow();
				}

			//PARTEA DE SUS
			
			glColor3f(currentTopColor.r(), currentTopColor.g(), currentTopColor.b());
			glBegin(GL_QUADS);
			


			glVertex3f(j-0.5, cube[newi][newj] , i-0.5);
			glVertex3f(j-0.5, cube[newi][newj] , i+0.5);
			glVertex3f(j+0.5, cube[newi][newj] , i+0.5);
			glVertex3f(j + 0.5, cube[newi][newj], i - 0.5);
			glEnd();
			
			// SIDE1

			glColor3f(currentSideColor.r(), currentSideColor.g(), currentSideColor.b());

			glBegin(GL_QUADS);

			glVertex3f(j - 0.5, 0.0f, i - 0.5);
			glVertex3f(j - 0.5, cube[newi][newj], i - 0.5);
			glVertex3f(j + 0.5, cube[newi][newj], i - 0.5);
			glVertex3f(j + 0.5, 0.0f, i - 0.5);

			glEnd();

			//SIDE2
			
			glBegin(GL_QUADS);

			glVertex3f(j + 0.5, 0.0f, i - 0.5);
			glVertex3f(j + 0.5, cube[newi][newj], i - 0.5);
			glVertex3f(j + 0.5, cube[newi][newj], i + 0.5);
			glVertex3f(j + 0.5, 0.0f, i + 0.5);

			glEnd();

			//SIDE3

			
			glBegin(GL_QUADS);

			glVertex3f(j + 0.5, 0.0f, i + 0.5);
			glVertex3f(j + 0.5, cube[newi][newj], i + 0.5);
			glVertex3f(j - 0.5, cube[newi][newj], i + 0.5);
			glVertex3f(j - 0.5, 0.0f, i + 0.5);

			glEnd();

			//SIDE 4

			glBegin(GL_QUADS);

			glVertex3f(j - 0.5, 0.0f, i + 0.5);
			glVertex3f(j - 0.5, cube[newi][newj], i + 0.5);
			glVertex3f(j - 0.5, cube[newi][newj], i - 0.5);
			glVertex3f(j - 0.5, 0.0f, i - 0.5);

			glEnd();



			

		}
	}

	
	
	
	glLightfv(GL_LIGHT0, GL_POSITION, light_position);
	


		


	
	
	
	

	

	glutSwapBuffers();
}



void exportToOBJ()
{

	std::cout << "SE SALVEAZA...";

	std::ofstream MATFile("object_001.mtl");
	MATFile << "# GENERATED BY A TERRAIN-MAKER SOFTWARE" << '\n' << "# COPYRIGHT BENTA ANDREI (c)  2018 PROIECT ATESTAT" << '\n';
	MATFile << std::fixed;
	MATFile << std::setprecision(4);
	Color expColor = Color::Grass();
	MATFile << "newmtl GRASS\n" << "	Kd " << expColor.r() - 0.3 << " " << expColor.g() - 0.3 << " " << expColor.b() - 0.3 << '\n';
	expColor = Color::Sand();
	MATFile << "newmtl SAND\n" << "	Kd " << expColor.r() - 0.3 << " " << expColor.g() - 0.3 << " " << expColor.b() - 0.3 << '\n';
	expColor = Color::Dirt();
	MATFile << "newmtl DIRT\n" << "	Kd " << expColor.r() - 0.3 << " " << expColor.g() - 0.3 << " " << expColor.b() - 0.3 << '\n';


	MATFile.close();

	
	std::ofstream OBJFile("object_001.obj");

	OBJFile << "# GENERATED BY A TERRAIN-MAKER SOFTWARE" << '\n' << "# COPYRIGHT BENTA ANDREI (c)  2018 PROIECT ATESTAT" << '\n';

	int k = 1, nrpoints = 0;

	OBJFile << "# OBJECT SURFACE" << 1 << '\n';

	OBJFile << "mtllib object_001.mtl \n \n";

	OBJFile << std::fixed;
	OBJFile << std::setprecision(4);

	std::vector<int> colorVector;

	for (float i = 0.5f; i < dimPlanx; i += 1)
	{
		for (float j = 0.5f; j < dimPlanz; j += 1)
		{
			
			size_t newi = i - 0.5, newj = j - 0.5;
			
			

			//PARTEA DE SUS

			// 1 pt iarba, 2 pt nisip, 3 pt zapada, 4 pt noroi, 5 pt nisip inchis, 6 pt nisip deschis
			
			int currentColorOBJSide = 4;
			int currentColorOBJTop = 1;
			if (cube[newi][newj] < waterHeight + 2)
			{
					currentColorOBJTop = 2;
					currentColorOBJSide = 5;
			}
			else
				if (cube[newi][newj] > 100)
				{
						currentColorOBJTop = 3;
						currentColorOBJSide = 6;
				}

			

			OBJFile << "v  " << j - 0.5 << " " << cube[newi][newj] << " " << i - 0.5 << '\n'; nrpoints++;
			OBJFile << "v  " << j - 0.5 << " " << cube[newi][newj] << " " << i + 0.5 << '\n'; nrpoints++;
			OBJFile << "v  " << j + 0.5 << " " << cube[newi][newj] << " " << i + 0.5 << '\n'; nrpoints++;
			OBJFile << "v  " << j + 0.5 << " " << cube[newi][newj] << " " << i - 0.5 << '\n'; nrpoints++;
			
			colorVector.push_back(currentColorOBJTop);

			// SIDE1
			
			

			

			OBJFile << "v  " << j - 0.5 << " " << 0.0f << " " << i - 0.5 << '\n'; nrpoints++;
			OBJFile << "v  " << j - 0.5 << " " << cube[newi][newj] << " " << i - 0.5 << '\n'; nrpoints++;
			OBJFile << "v  " << j + 0.5 << " " << cube[newi][newj] << " " << i - 0.5 << '\n'; nrpoints++;
			OBJFile << "v  " << j + 0.5 << " " << 0.0f << " " << i - 0.5 << '\n'; nrpoints++;

			colorVector.push_back(currentColorOBJSide);
			

			//SIDE2

			

			OBJFile << "v  " << j + 0.5 << " " << 0.0f << " " << i - 0.5 << '\n'; nrpoints++;
			OBJFile << "v  " << j + 0.5 << " " << cube[newi][newj] << " " << i - 0.5 << '\n'; nrpoints++;
			OBJFile << "v  " << j + 0.5 << " " << cube[newi][newj] << " " << i + 0.5 << '\n'; nrpoints++;
			OBJFile << "v  " << j + 0.5 << " " << 0.0f << " " << i + 0.5 << '\n'; nrpoints++;

			colorVector.push_back(currentColorOBJSide);

			//SIDE3


			

			OBJFile << "v  " << j + 0.5 << " " << 0.0f << " " << i + 0.5 << '\n'; nrpoints++;
			OBJFile << "v  " << j + 0.5 << " " << cube[newi][newj] << " " << i + 0.5 << '\n'; nrpoints++;
			OBJFile << "v  " << j - 0.5 << " " << cube[newi][newj] << " " << i + 0.5 << '\n'; nrpoints++;
			OBJFile << "v  " << j - 0.5 << " " << 0.0f << " " << i + 0.5 << '\n'; nrpoints++;

			
			colorVector.push_back(currentColorOBJSide);
			//SIDE 4

			

			OBJFile << "v  " << j - 0.5 << " " << 0.0f << " " << i + 0.5 << '\n'; nrpoints++;
			OBJFile << "v  " << j - 0.5 << " " << cube[newi][newj] << " " << i + 0.5 << '\n'; nrpoints++;
			OBJFile << "v  " << j - 0.5 << " " << cube[newi][newj] << " " << i - 0.5 << '\n'; nrpoints++;
			OBJFile << "v  " << j - 0.5 << " " << 0.0f << " " << i - 0.5 << '\n'; nrpoints++;

			colorVector.push_back(currentColorOBJSide);
			


			OBJFile << '\n';
			

			
			
		

		
			
		

			OBJFile << '\n';


			k++;
			OBJFile << '\n';



		
		}
	}
	int step = 0;
	OBJFile << "g " << "OBJ_" << 1 << '\n' << "f ";

	
	int vectorindex = 0;

	switch (colorVector[0])
	{

	case 1:  OBJFile << '\n' << "usemtl GRASS\n"; break;
	case 2:  OBJFile << '\n' << "usemtl SAND\n"; break;
	case 4:  OBJFile << '\n' << "usemtl DIRT\n"; break;
	default: OBJFile << '\n' << "usemtl DIRT\n"; break;
	}

	for (int i = 1; i <= nrpoints; i++)
	{

		

		

		step++;
		
		if (step == 5){


			switch (colorVector[vectorindex+1])
			{

			case 1:  OBJFile << '\n' << "usemtl GRASS\n"; break;
			case 2:  OBJFile << '\n' << "usemtl SAND\n"; break;
			case 4:  OBJFile << '\n' << "usemtl DIRT\n"; break;
			default: OBJFile << '\n' << "usemtl DIRT\n"; break;
			}
			vectorindex++;
			
			OBJFile << '\n' << "f "; step = 1; 
		
		
		}

		OBJFile << i << " ";
		
		
	}





	

	OBJFile.close();

	std::cout << "SALVAT!";
}

void changeSize(int w, int h)
{
	screen_width=w;
	screen_height=h;

	if(h == 0)
		h = 1;

	float ratio = 1.0*w/h;

	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	glViewport(0, 0, w, h);
	gluPerspective(45.0f, ratio, 1.0f, 1000.0f);
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
	gluLookAt(0.0f, 0.0f, 50.0f, 0.0f, 0.0f, -1.0f, 0.0f, 1.0f, 0.0f);
}

void aplicarePerlin(float z)
{
	


	for (unsigned int i = 1; i < dimPlanx; i++)
	{
		for (unsigned int j = 1; j < dimPlanz; j++)
		{
			float xx = (float) i / (float)dimPlanx;
			float yy = (float) j / (float)dimPlanz;

			double pp = amplitude * pn.noise(frequency*xx, frequency*yy, z*frequency);
			
			
			cube[i][j] = pp;


		}

	

	}

	
}

void octavePerlin(float z, int octaves)
{



	for (unsigned int i = 1; i < dimPlanx; i++)
	{
		for (unsigned int j = 1; j < dimPlanz; j++)
		{

			double localFrequency = frequency/persistenta;
			double localAmplitude = amplitude;
			double maxValue = 0;

			float xx = (float)i / (float)dimPlanx;
			float yy = (float)j / (float)dimPlanz;

			for (int kk = 0; kk < octaves; kk++){

				

				

			

				

				double pp = localAmplitude * pn.noise(localFrequency*xx, localFrequency*yy, localFrequency*z);
				maxValue += localAmplitude;

				

				cube[i][j] += pp;
				localAmplitude *= persistenta;
				localFrequency *= 2;
				
			}
			
			cube[i][j] /= maxValue;
			cube[i][j] *= amplitude;
		}



	}
}



void processNormalKeys(unsigned char key, int x, int y)
{


	
	switch(key)
	{
		case 't':
			//process
			glutPostRedisplay();
			break;

		case 'j':
			camx -= scrollSpeed;
			break;

		case 'l':
			camx += scrollSpeed;
			break;

		case 'i':
			camy += scrollSpeed;
			break;

		case 'k':
			camy -= scrollSpeed;
			break;

		case 'y':
			camdepth += scrollSpeed;
			break;
		case 'h':
			camdepth -= scrollSpeed;
			break;


		case '0':
			
				keyState++;
				keyState %= 5;
				printData();
			
		break;


		case 's':
			exportToOBJ();
			break;



		case 'z':
		
			octavePerlin(perlinZ, 5);

			break;
		

		

		case '+':
			switch (keyState)
			{
			case 0:
				if (seed < 4990){ seed += 10; pn = PerlinNoise(seed); }
				break;
			case 1:
				if(amplitude < 200.0f)amplitude += 10.0f;
				break;
			case 2:
				if(frequency < 100.0f)frequency += 0.4f;
				break;
			case 3:
				if (perlinZ < 1.0f)
					perlinZ += 0.1f;
			case 4:
				if (persistenta < 30.0f)
					persistenta += 0.5f;
			default:
				break;
			}
			printData();
			aplicarePerlin(perlinZ);

			break;



		case '-':
			switch (keyState)
			{
			case 0:
				if (seed > 0){ seed -= 10; pn = PerlinNoise(seed); }
				break;
			case 1:
				if (amplitude > 0.0f)amplitude -= 10.0f;
				break;
			case 2:
				if (frequency > 0.0f)frequency -= 0.5f;
				break;
			case 3:
				if (perlinZ > 0.0f)
					perlinZ -= 0.1f;
			case 4:
				if (persistenta > 0.5f)
					persistenta -= 0.5f;
			default:
				break;
			}
			printData();

			aplicarePerlin(perlinZ);
			break;




	
	


	}
	

}



int main(int argc, char* argv[])
{
	std::cout << "Introduceti lungimea si latimea suprafetei ( 2 <= dimensiuni <= 400 )\n";
	std::cin >> dimPlanx >> dimPlanz;
	
	while (dimPlanx > 400 || dimPlanz > 400 || dimPlanx < 2 || dimPlanz < 2)
	{
		std::cout << "Dimensiuni prea mari! Planul de lucru nu poate fi mai mare de 400x400\nIntroduceti lungimea si latimea suprafetei:  ";
		std::cin >> dimPlanx >> dimPlanz;
	}

	std::cout << "Inroduceti seedul initial ( 1 <= seed <= 5000, 0 pentru seed aleatoriu ).\n";
	std::cin >> seed;

	while (seed > 5000)
	{
		std::cout << seed << "Seedul trebuie sa fie cuprins intre 0 si 5000\n Introduceti seedul: ";
		std::cin >> seed;
	}
	

	//Initializeaza biblioteca
	glutInit(&argc, argv);
	//Culori, profunzime
	glutInitDisplayMode(GLUT_DEPTH | GLUT_DOUBLE | GLUT_RGBA);
	//Dimensiuni fereastra
	glutInitWindowPosition(100, 100);
	glutInitWindowSize(screen_width, screen_height);

	if (seed)
	pn = PerlinNoise(seed);
	else pn = PerlinNoise();

	aplicarePerlin(0);

	//Fereastra
	glutCreateWindow("First OpenGL Application");
	//Link catre functia de "refresh"
	glutDisplayFunc(renderScene);
	//Link catre functia de "stat"
	glutIdleFunc(renderScene);
	//Link functia de redimensionare
	glutReshapeFunc(changeSize);
	//Evenimente taste
	glutKeyboardFunc(processNormalKeys);
	//OpenGL parametri
	initOpenGL();
	printData();
	//Incepe loopul
	glutMainLoop();

	
	return 0;
}

